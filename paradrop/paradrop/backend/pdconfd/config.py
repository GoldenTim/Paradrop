import ipaddress
import os
import subprocess
from pprint import pprint

from paradrop.internal.utils.uci import OpenWrtConfig

CONFIG_DIR = "/etc/config"

class ConfigObject(object):
    typename = None
    required = []

    def commands(self, allConfigs):
        return []

    def missingOptions(self, data):
        missing = [x for x in self.required if x not in data]
        return missing

class ConfigDhcp(ConfigObject):
    typename = "dhcp"
    required = ["interface", "leasetime", "limit", "start"]

    def commands(self, allConfigs):
        # Look up the interface - may fail.
        interface = allConfigs[("interface", self.interface)]

        network = ipaddress.IPv4Network(u"{}/{}".format(
            interface.ipaddr, interface.netmask), strict=False)

        # TODO: Error checking!
        firstAddress = network.network_address + self.start
        lastAddress = firstAddress + self.limit

        leaseFile = "/tmp/dnsmasq-{}.leases".format(self.interface)
        pidFile = "/tmp/dnsmasq-{}.pid".format(self.interface)

        if False:
            # TODO: Figure out how to write a configuration file and have the
            # target daemon be able to load that file.  In principle this code
            # should work, but something about how Snappy handles filesystem or
            # process isolation breaks it.  We write the file
            # /etc/dnsmasq-foo.conf, it appears in the filesystem, but then
            # dnsmasq says it cannot find it.  Luckily, dnsmasq can be
            # configured either by command line arguments or by configuration
            # file.  Other daemons (e.g.  hostapd) are not so flexible, so we
            # need to solve this.
            outputPath = "/tmp/dnsmasq-{}.conf".format(self.interface)
            with open(outputPath, "w") as outputFile:
                outputFile.write("#" * 80 + "\n")
                outputFile.write("# dnsmasq configuration file generated by pdconfd\n")
                outputFile.write("# Source: {}\n".format(self.source))
                outputFile.write("# Section: config {} {}\n".format(
                    ConfigDhcp.typename, self.name))
                outputFile.write("#" * 80 + "\n")
                outputFile.write("interface={}\n".format(interface.ifname))
                outputFile.write("dhcp-range={},{},{}\n".format(
                    str(firstAddress), str(lastAddress), self.leasetime))
                outputFile.write("dhcp-leasefile={}\n".format(leaseFile))
            cmd = ["dnsmasq", "-C", outputPath]
        else:
            cmd = ["/apps/bin/dnsmasq", 
                    "--interface={}".format(interface.ifname),
                    "--dhcp-range={},{},{}".format(str(firstAddress), str(lastAddress), self.leasetime),
                    "--dhcp-leasefile={}".format(leaseFile),
                    "--pid-file={}".format(pidFile)]

        return [cmd]

    @classmethod
    def build(cls, source, name, options):
        dhcp = cls()
        dhcp.source = source
        dhcp.name = name
        dhcp.interface = options['interface']
        dhcp.leasetime = options['leasetime']
        dhcp.limit = int(options['limit'])
        dhcp.start = int(options['start'])
        return dhcp

class ConfigInterface(ConfigObject):
    typename = "interface"
    required = ["proto", "ifname"]

    def commands(self, allConfigs):
        commands = list()
        if self.proto == "static":
            cmd = ["ip", "addr", "flush", "dev", self.ifname]
            commands.append(cmd)

            cmd = ["ip", "addr", "add", 
                    "{}/{}".format(self.ipaddr, self.netmask),
                    "dev", self.ifname]
            commands.append(cmd)

            updown = "up" if self.enabled else "down"
            cmd = ["ip", "link", "set", "dev", self.ifname, updown]
            commands.append(cmd)

        return commands

    @classmethod
    def build(cls, source, name, options):
        interface = cls()
        interface.source = source
        interface.name = name
        interface.proto = options['proto']
        interface.ifname = options['ifname']
        if interface.proto == "static":
            interface.required.extend(["ipaddr", "netmask"])
            interface.ipaddr = options['ipaddr']
            interface.netmask = options['netmask']
        interface.enabled = True
        if "enabled" in options:
            interface.enabled = (options['enabled'] != '0')
        return interface

def findConfigFiles(search=None):
    """
    Look for and return a list of configuration files.  
    
    The behavior depends on whether the search argument is a file, a directory,
    or None.

    If search is None, return a list of files in the system config directory.
    If search is a file name (not a path), look for it in the working directory
    first, and the system directory second.  If search is a full path to a
    file, and it exists, then return that file.  If search is a directory,
    return the files in that directory.
    """
    if search is None:
        search = CONFIG_DIR

    files = list()
    if os.path.isfile(search):
        files.append(search)
    elif os.path.isdir(search):
        for fn in os.listdir(search):
            path = "{}/{}".format(search, fn)
            files.append(path)
    else:
        path = "{}/{}".format(CONFIG_DIR, search)
        if os.path.isfile(path):
            files.append(path)

    return files

def loadConfig(search=None):
    files = findConfigFiles(search)

    # Map (type, name) -> config
    allConfigs = dict()

    newConfigs = list()
    commands = list()

    # First, parse all of the new configuration files.  There may be
    # dependencies across files, so we read them all in first.
    for fn in files:
        print("Trying file {}".format(fn))
        uci = OpenWrtConfig(fn)
        config = uci.readConfig()

        if config is None:
            print("Error reading file.")
            continue

        for section, options in config:
            if section['type'] == "interface":
                interface = ConfigInterface.build(fn, section['name'], options)
                allConfigs[(section['type'], section['name'])] = interface
                newConfigs.append(interface)
            elif section['type'] == "dhcp":
                dhcp = ConfigDhcp.build(fn, section['name'], options)
                allConfigs[(section['type'], section['name'])] = dhcp
                newConfigs.append(dhcp)

    # Generate list of commands to implement configuration.
    for config in newConfigs:
        commands.extend(config.commands(allConfigs))

    # Finally, execute the commands.
    for cmd in commands:
        print("Command: {}".format(" ".join(cmd)))
        result = subprocess.call(cmd)
        print("Result: {}".format(result))

    return True

if __name__=="__main__":
    loadConfig()

